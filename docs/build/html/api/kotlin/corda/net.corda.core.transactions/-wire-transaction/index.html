<HTML>
<HEAD>
<meta charset="UTF-8">
<title>WireTransaction - corda</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">corda</a>&nbsp;/&nbsp;<a href="../index.html">net.corda.core.transactions</a>&nbsp;/&nbsp;<a href=".">WireTransaction</a><br/>
<br/>
<h1>WireTransaction</h1>
<code><span class="keyword">class </span><span class="identifier">WireTransaction</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../-base-transaction/index.html"><span class="identifier">BaseTransaction</span></a><span class="symbol">, </span><a href="../-traversable-transaction/index.html"><span class="identifier">TraversableTransaction</span></a></code>
<p>A transaction ready for serialisation, without any signatures attached. A WireTransaction is usually wrapped
by a <a href="../-signed-transaction/index.html">SignedTransaction</a> that carries the signatures over this payload. The hash of the wire transaction is
the identity of the transaction, that is, it's possible for two <a href="../-signed-transaction/index.html">SignedTransaction</a>s with different sets of
signatures to have the same identity hash.</p>
<h3>Constructors</h3>
<table>
<tbody>
<tr>
<td>
<a href="-init-.html">&lt;init&gt;</a></td>
<td>
<code><span class="identifier">WireTransaction</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.WireTransaction$<init>(kotlin.collections.List((net.corda.core.contracts.StateRef)), kotlin.collections.List((net.corda.core.crypto.SecureHash)), kotlin.collections.List((net.corda.core.contracts.TransactionState((net.corda.core.contracts.ContractState)))), kotlin.collections.List((net.corda.core.contracts.Command)), net.corda.core.crypto.Party, kotlin.collections.List((net.corda.core.crypto.CompositeKey)), net.corda.core.contracts.TransactionType, net.corda.core.contracts.Timestamp)/inputs">inputs</span><span class="symbol">:</span>&nbsp;<span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.contracts/-state-ref/index.html"><span class="identifier">StateRef</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.WireTransaction$<init>(kotlin.collections.List((net.corda.core.contracts.StateRef)), kotlin.collections.List((net.corda.core.crypto.SecureHash)), kotlin.collections.List((net.corda.core.contracts.TransactionState((net.corda.core.contracts.ContractState)))), kotlin.collections.List((net.corda.core.contracts.Command)), net.corda.core.crypto.Party, kotlin.collections.List((net.corda.core.crypto.CompositeKey)), net.corda.core.contracts.TransactionType, net.corda.core.contracts.Timestamp)/attachments">attachments</span><span class="symbol">:</span>&nbsp;<span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.crypto/-secure-hash/index.html"><span class="identifier">SecureHash</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.WireTransaction$<init>(kotlin.collections.List((net.corda.core.contracts.StateRef)), kotlin.collections.List((net.corda.core.crypto.SecureHash)), kotlin.collections.List((net.corda.core.contracts.TransactionState((net.corda.core.contracts.ContractState)))), kotlin.collections.List((net.corda.core.contracts.Command)), net.corda.core.crypto.Party, kotlin.collections.List((net.corda.core.crypto.CompositeKey)), net.corda.core.contracts.TransactionType, net.corda.core.contracts.Timestamp)/outputs">outputs</span><span class="symbol">:</span>&nbsp;<span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.contracts/-transaction-state/index.html"><span class="identifier">TransactionState</span></a><span class="symbol">&lt;</span><a href="../../net.corda.core.contracts/-contract-state/index.html"><span class="identifier">ContractState</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.WireTransaction$<init>(kotlin.collections.List((net.corda.core.contracts.StateRef)), kotlin.collections.List((net.corda.core.crypto.SecureHash)), kotlin.collections.List((net.corda.core.contracts.TransactionState((net.corda.core.contracts.ContractState)))), kotlin.collections.List((net.corda.core.contracts.Command)), net.corda.core.crypto.Party, kotlin.collections.List((net.corda.core.crypto.CompositeKey)), net.corda.core.contracts.TransactionType, net.corda.core.contracts.Timestamp)/commands">commands</span><span class="symbol">:</span>&nbsp;<span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.contracts/-command/index.html"><span class="identifier">Command</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.WireTransaction$<init>(kotlin.collections.List((net.corda.core.contracts.StateRef)), kotlin.collections.List((net.corda.core.crypto.SecureHash)), kotlin.collections.List((net.corda.core.contracts.TransactionState((net.corda.core.contracts.ContractState)))), kotlin.collections.List((net.corda.core.contracts.Command)), net.corda.core.crypto.Party, kotlin.collections.List((net.corda.core.crypto.CompositeKey)), net.corda.core.contracts.TransactionType, net.corda.core.contracts.Timestamp)/notary">notary</span><span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.crypto/-party/index.html"><span class="identifier">Party</span></a><span class="symbol">?</span><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.WireTransaction$<init>(kotlin.collections.List((net.corda.core.contracts.StateRef)), kotlin.collections.List((net.corda.core.crypto.SecureHash)), kotlin.collections.List((net.corda.core.contracts.TransactionState((net.corda.core.contracts.ContractState)))), kotlin.collections.List((net.corda.core.contracts.Command)), net.corda.core.crypto.Party, kotlin.collections.List((net.corda.core.crypto.CompositeKey)), net.corda.core.contracts.TransactionType, net.corda.core.contracts.Timestamp)/signers">signers</span><span class="symbol">:</span>&nbsp;<span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.crypto/-composite-key/index.html"><span class="identifier">CompositeKey</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.WireTransaction$<init>(kotlin.collections.List((net.corda.core.contracts.StateRef)), kotlin.collections.List((net.corda.core.crypto.SecureHash)), kotlin.collections.List((net.corda.core.contracts.TransactionState((net.corda.core.contracts.ContractState)))), kotlin.collections.List((net.corda.core.contracts.Command)), net.corda.core.crypto.Party, kotlin.collections.List((net.corda.core.crypto.CompositeKey)), net.corda.core.contracts.TransactionType, net.corda.core.contracts.Timestamp)/type">type</span><span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.contracts/-transaction-type/index.html"><span class="identifier">TransactionType</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.WireTransaction$<init>(kotlin.collections.List((net.corda.core.contracts.StateRef)), kotlin.collections.List((net.corda.core.crypto.SecureHash)), kotlin.collections.List((net.corda.core.contracts.TransactionState((net.corda.core.contracts.ContractState)))), kotlin.collections.List((net.corda.core.contracts.Command)), net.corda.core.crypto.Party, kotlin.collections.List((net.corda.core.crypto.CompositeKey)), net.corda.core.contracts.TransactionType, net.corda.core.contracts.Timestamp)/timestamp">timestamp</span><span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.contracts/-timestamp/index.html"><span class="identifier">Timestamp</span></a><span class="symbol">?</span><span class="symbol">)</span></code>
<p>A transaction ready for serialisation, without any signatures attached. A WireTransaction is usually wrapped
by a <a href="../-signed-transaction/index.html">SignedTransaction</a> that carries the signatures over this payload. The hash of the wire transaction is
the identity of the transaction, that is, it's possible for two <a href="../-signed-transaction/index.html">SignedTransaction</a>s with different sets of
signatures to have the same identity hash.</p>
</td>
</tr>
</tbody>
</table>
<h3>Properties</h3>
<table>
<tbody>
<tr>
<td>
<a href="attachments.html">attachments</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">attachments</span><span class="symbol">: </span><span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.crypto/-secure-hash/index.html"><span class="identifier">SecureHash</span></a><span class="symbol">&gt;</span></code>
<p>Hashes of the ZIP/JAR files that are needed to interpret the contents of this wire transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="commands.html">commands</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">commands</span><span class="symbol">: </span><span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.contracts/-command/index.html"><span class="identifier">Command</span></a><span class="symbol">&gt;</span></code>
<p>Ordered list of (<a href="../../net.corda.core.contracts/-command-data.html">CommandData</a>, <a href="http://docs.oracle.com/javase/6/docs/api/java/security/PublicKey.html">PublicKey</a>) pairs that instruct the contracts what to do.</p>
</td>
</tr>
<tr>
<td>
<a href="id.html">id</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">id</span><span class="symbol">: </span><a href="../../net.corda.core.crypto/-secure-hash/index.html"><span class="identifier">SecureHash</span></a></code></td>
</tr>
<tr>
<td>
<a href="inputs.html">inputs</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">inputs</span><span class="symbol">: </span><span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.contracts/-state-ref/index.html"><span class="identifier">StateRef</span></a><span class="symbol">&gt;</span></code>
<p>Pointers to the input states on the ledger, identified by (tx identity hash, output index).</p>
</td>
</tr>
<tr>
<td>
<a href="merkle-tree.html">merkleTree</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">merkleTree</span><span class="symbol">: </span><a href="../../net.corda.core.crypto/-merkle-tree/index.html"><span class="identifier">MerkleTree</span></a></code>
<p>Builds whole Merkle tree for a transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="serialized.html">serialized</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">serialized</span><span class="symbol">: </span><a href="../../net.corda.core.serialization/-serialized-bytes/index.html"><span class="identifier">SerializedBytes</span></a><span class="symbol">&lt;</span><span class="identifier">WireTransaction</span><span class="symbol">&gt;</span></code></td>
</tr>
</tbody>
</table>
<h3>Inherited Properties</h3>
<table>
<tbody>
<tr>
<td>
<a href="../-traversable-transaction/available-component-hashes.html">availableComponentHashes</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">val </span><span class="identifier">availableComponentHashes</span><span class="symbol">: </span><span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.crypto/-secure-hash/index.html"><span class="identifier">SecureHash</span></a><span class="symbol">&gt;</span></code>
<p>Calculate the hashes of the sub-components of the transaction, that are used to build its Merkle tree.
The root of the tree is the transaction identifier. The tree structure is helpful for privacy, please
see the user-guide section "Transaction tear-offs" to learn more about this topic.</p>
</td>
</tr>
<tr>
<td>
<a href="../-traversable-transaction/available-components.html">availableComponents</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">val </span><span class="identifier">availableComponents</span><span class="symbol">: </span><span class="identifier">List</span><span class="symbol">&lt;</span><span class="identifier">Any</span><span class="symbol">&gt;</span></code>
<p>Returns a flattened list of all the components that are present in the transaction, in the following order:</p>
</td>
</tr>
<tr>
<td>
<a href="../-base-transaction/must-sign.html">mustSign</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">mustSign</span><span class="symbol">: </span><span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.crypto/-composite-key/index.html"><span class="identifier">CompositeKey</span></a><span class="symbol">&gt;</span></code>
<p>Composite keys that need to be fulfilled by signatures in order for the transaction to be valid.
In a <a href="../-signed-transaction/index.html">SignedTransaction</a> this list is used to check whether there are any missing signatures. Note that
there is nothing that forces the list to be the <emph>correct</emph> list of signers for this transaction until
the transaction is verified by using <a href="../-ledger-transaction/verify.html">LedgerTransaction.verify</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../-base-transaction/notary.html">notary</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">notary</span><span class="symbol">: </span><a href="../../net.corda.core.crypto/-party/index.html"><span class="identifier">Party</span></a><span class="symbol">?</span></code>
<p>If present, the notary for this transaction. If absent then the transaction is not notarised at all.
This is intended for issuance/genesis transactions that don't consume any other states and thus can't
double spend anything.</p>
</td>
</tr>
<tr>
<td>
<a href="../-base-transaction/outputs.html">outputs</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">outputs</span><span class="symbol">: </span><span class="identifier">List</span><span class="symbol">&lt;</span><a href="../../net.corda.core.contracts/-transaction-state/index.html"><span class="identifier">TransactionState</span></a><span class="symbol">&lt;</span><a href="../../net.corda.core.contracts/-contract-state/index.html"><span class="identifier">ContractState</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code>
<p>Ordered list of states defined by this transaction, along with the associated notaries.</p>
</td>
</tr>
<tr>
<td>
<a href="../-base-transaction/timestamp.html">timestamp</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">timestamp</span><span class="symbol">: </span><a href="../../net.corda.core.contracts/-timestamp/index.html"><span class="identifier">Timestamp</span></a><span class="symbol">?</span></code>
<p>If specified, a time window in which this transaction may have been notarised. Contracts can check this
time window to find out when a transaction is deemed to have occurred, from the ledger's perspective.</p>
</td>
</tr>
<tr>
<td>
<a href="../-base-transaction/type.html">type</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">type</span><span class="symbol">: </span><a href="../../net.corda.core.contracts/-transaction-type/index.html"><span class="identifier">TransactionType</span></a></code>
<p>Pointer to a class that defines the behaviour of this transaction: either normal, or "notary changing".</p>
</td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="build-filtered-transaction.html">buildFilteredTransaction</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">buildFilteredTransaction</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.WireTransaction$buildFilteredTransaction(kotlin.Function1((kotlin.Any, kotlin.Boolean)))/filtering">filtering</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">Any</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">Boolean</span><span class="symbol">)</span><span class="symbol">: </span><a href="../-filtered-transaction/index.html"><span class="identifier">FilteredTransaction</span></a></code>
<p>Build filtered transaction using provided filtering functions.</p>
</td>
</tr>
<tr>
<td>
<a href="equals.html">equals</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">equals</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.WireTransaction$equals(kotlin.Any)/other">other</span><span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">?</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Boolean</span></code></td>
</tr>
<tr>
<td>
<a href="filter-with-fun.html">filterWithFun</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">filterWithFun</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.WireTransaction$filterWithFun(kotlin.Function1((kotlin.Any, kotlin.Boolean)))/filtering">filtering</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><span class="identifier">Any</span><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">Boolean</span><span class="symbol">)</span><span class="symbol">: </span><a href="../-filtered-leaves/index.html"><span class="identifier">FilteredLeaves</span></a></code>
<p>Construction of partial transaction from WireTransaction based on filtering.</p>
</td>
</tr>
<tr>
<td>
<a href="hash-code.html">hashCode</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">hashCode</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Int</span></code></td>
</tr>
<tr>
<td>
<a href="out-ref.html">outRef</a></td>
<td>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.contracts/-contract-state/index.html"><span class="identifier">ContractState</span></a><span class="symbol">&gt;</span> <span class="identifier">outRef</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.WireTransaction$outRef(kotlin.Int)/index">index</span><span class="symbol">:</span>&nbsp;<span class="identifier">Int</span><span class="symbol">)</span><span class="symbol">: </span><a href="../../net.corda.core.contracts/-state-and-ref/index.html"><span class="identifier">StateAndRef</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Returns a <a href="../../net.corda.core.contracts/-state-and-ref/index.html">StateAndRef</a> for the given output index.</p>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.contracts/-contract-state/index.html"><span class="identifier">ContractState</span></a><span class="symbol">&gt;</span> <span class="identifier">outRef</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.WireTransaction$outRef(net.corda.core.contracts.ContractState)/state">state</span><span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.contracts/-contract-state/index.html"><span class="identifier">ContractState</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="../../net.corda.core.contracts/-state-and-ref/index.html"><span class="identifier">StateAndRef</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code>
<p>Returns a <a href="../../net.corda.core.contracts/-state-and-ref/index.html">StateAndRef</a> for the requested output state, or throws <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</a> if not found.</p>
</td>
</tr>
<tr>
<td>
<a href="to-ledger-transaction.html">toLedgerTransaction</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">toLedgerTransaction</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.WireTransaction$toLedgerTransaction(net.corda.core.node.ServicesForResolution)/services">services</span><span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.node/-services-for-resolution/index.html"><span class="identifier">ServicesForResolution</span></a><span class="symbol">)</span><span class="symbol">: </span><a href="../-ledger-transaction/index.html"><span class="identifier">LedgerTransaction</span></a></code>
<p>Looks up identities and attachments from storage to generate a <a href="../-ledger-transaction/index.html">LedgerTransaction</a>. A transaction is expected to
have been fully resolved using the resolution flow by this point.</p>
</td>
</tr>
<tr>
<td>
<a href="to-string.html">toString</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">toString</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">String</span></code></td>
</tr>
</tbody>
</table>
<h3>Inherited Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="../-base-transaction/check-invariants.html">checkInvariants</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">checkInvariants</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
</tbody>
</table>
<h3>Companion Object Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="deserialize.html">deserialize</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">deserialize</span><span class="symbol">(</span><span class="identifier" id="net.corda.core.transactions.WireTransaction.Companion$deserialize(net.corda.core.serialization.SerializedBytes((net.corda.core.transactions.WireTransaction)), com.esotericsoftware.kryo.Kryo)/data">data</span><span class="symbol">:</span>&nbsp;<a href="../../net.corda.core.serialization/-serialized-bytes/index.html"><span class="identifier">SerializedBytes</span></a><span class="symbol">&lt;</span><span class="identifier">WireTransaction</span><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier" id="net.corda.core.transactions.WireTransaction.Companion$deserialize(net.corda.core.serialization.SerializedBytes((net.corda.core.transactions.WireTransaction)), com.esotericsoftware.kryo.Kryo)/kryo">kryo</span><span class="symbol">:</span>&nbsp;<span class="identifier">Kryo</span>&nbsp;<span class="symbol">=</span>&nbsp;threadLocalP2PKryo()<span class="symbol">)</span><span class="symbol">: </span><span class="identifier">WireTransaction</span></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
